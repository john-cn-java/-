### 数据结构与算法 - 线性结构和非线性结构

#### 线性结构

1. 数据元素之间存在 ***一对一*** 的线性关系
2. **顺序存储结构**：顺序表中存储的元素是**连续**的，在物理地址上连续一块儿的
3. **链式存储结构**：链表中存储的元素**不一定是连续**的，元素节点中存放的是数据元素以及相邻元素的地址信息
4. 常见结构：`数组`，`队列`，`链表`，`栈`...



#### 非线性结构

1. 元素之间不一定存在 ***一对一***  的线性关系的，一个元素可能有**多个前置**元素，也有可能有**多个后置**元素
2. 常见结构：二位数组，多维数组，广义表，**树结构**，**图结构**



---



#### SparseArray 稀疏数组





> 当一个数组中，大部分元素相同时，可以使用 **稀疏数组** 来保存该数组

**处理方法：**

- 记录数组一共有多少行，多少列，有多少个不同的值
- 把具有不同值元素的行、列、值，记录在一个小规模的数组中，从而缩小数据的规模

**例如：**

有如下一个二维数组：

**6行 6列**，数组中相同的元素为**0**，<span style='color:green'>**绿色代表行**</span>，<span style='color:blue'>**蓝色代表列**</span> ，<span style='color:red'>**红色代表不同值**</span>

> 
>
> 这里为了方便理解和说明，并没有使用数组中的索引来画表格，实际编码中，注意切换
>
> 

| <span style='color:green'>行</span>  <span style='color:blue'>列</span> | <span style='color:blue'>1</span> | <span style='color:blue'>2</span> | <span style='color:blue'>3</span> | <span style='color:blue'>4</span> | <span style='color:blue'>5</span> | <span style='color:blue'>6</span> |
| :----------------------------------------------------------: | :-------------------------------: | :-------------------------------: | :-------------------------------: | :-------------------------------: | :-------------------------------: | :-------------------------------: |
|              <span style='color:green'>1</span>              |                 0                 |                 0                 |                 0                 |                 0                 | <span style='color:red'>7</span>  |                 0                 |
|              <span style='color:green'>2</span>              |                 0                 |                 0                 | <span style='color:red'>-1</span> |                 0                 |                 0                 |                 0                 |
|              <span style='color:green'>3</span>              |                 0                 | <span style='color:red'>5</span>  |                 0                 |                 0                 |                 0                 |                 0                 |
|              <span style='color:green'>4</span>              |                 0                 |                 0                 |                 0                 | <span style='color:red'>-9</span> |                 0                 |                 0                 |
|              <span style='color:green'>5</span>              |                 0                 |                 0                 |                 0                 |                 0                 |                 0                 | <span style='color:red'>7</span>  |
|              <span style='color:green'>6</span>              |                 0                 | <span style='color:red'>54</span> |                 0                 | <span style='color:red'>5</span>  |                 0                 |                 0                 |

​	我们按照普通的数组来存储的话，会存储**36**个元素

​	转换成 **稀疏数组** 试试：

1. 记录数组一共有多少 <span style='color:green'>**行**</span>，<span style='color:blue'>**列**</span>, <span style='color:red'>**不同值**</span>

   给定数组一共有 <span style='color:green'>**6行**</span> ，<span style='color:blue'>**6列**</span>，<span style='color:red'>**7个不同值**</span>，那么 **稀疏数组** **第一行**就记录这些信息

   | <span style='color:green'>行</span>  <span style='color:blue'>列</span> |    <span style='color:blue'>1</span>     |    <span style='color:blue'>2</span>    |     <span style='color:blue'>3</span>      |
   | :----------------------------------------------------------: | :--------------------------------------: | :-------------------------------------: | :----------------------------------------: |
   |              <span style='color:green'>1</span>              | <span style='color:green'>6（行）</span> | <span style='color:blue'>6（列）</span> | <span style='color:red'>7（不同值）</span> |
   |              <span style='color:green'>2</span>              |                                          |                                         |                                            |
   |              <span style='color:green'>3</span>              |                                          |                                         |                                            |
   |              <span style='color:green'>4</span>              |                                          |                                         |                                            |
   |             <span style='color:green'>...</span>             |                                          |                                         |                                            |

2. 记录不同值的 <span style='color:green'>**行**</span>，<span style='color:blue'>**列**</span>, <span style='color:red'>**不同值**</span>。

   从第二行开始，记录这些不同值在原来数组中的 <span style='color:green'>**行**</span>，<span style='color:blue'>**列**</span>, <span style='color:red'>**值**</span> 。	

   | <span style='color:green'>行</span>  <span style='color:blue'>列</span> |       <span style='color:blue'>1</span>        |       <span style='color:blue'>2</span>       |        <span style='color:blue'>3</span>         |
   | :----------------------------------------------------------: | :--------------------------------------------: | :-------------------------------------------: | :----------------------------------------------: |
   |              <span style='color:green'>1</span>              | <span style='color:green'>（共）6（行）</span> | <span style='color:blue'>（共）6（列）</span> | <span style='color:red'>（共）7（不同值）</span> |
   |              <span style='color:green'>2</span>              | <span style='color:green'>（第）2（行）</span> | <span style='color:blue'>（第）3（列）</span> |    <span style='color:red'>（value）-1</span>    |
   |              <span style='color:green'>3</span>              | <span style='color:green'>（第）3（行）</span> | <span style='color:blue'>（第）2（列）</span> |    <span style='color:red'>（value）5</span>     |
   |              <span style='color:green'>4</span>              | <span style='color:green'>（第）4（行）</span> | <span style='color:blue'>（第）4（列）</span> |    <span style='color:red'>（value）-9</span>    |
   |              <span style='color:green'>5</span>              | <span style='color:green'>（第）5（行）</span> | <span style='color:blue'>（第）6（列）</span> |    <span style='color:red'>（value）7</span>     |
   |              <span style='color:green'>6</span>              | <span style='color:green'>（第）6（行）</span> | <span style='color:blue'>（第）2（列）</span> |    <span style='color:red'>（value）54</span>    |
   |              <span style='color:green'>7</span>              |      <span style='color:green'>...</span>      |      <span style='color:blue'>...</span>      |        <span style='color:red'>...</span>        |

   到此 **稀疏数组** 记录完毕，再一次阅读这个 **稀疏数组** ：

   **第一行** ：表示原来的数组一共有 <span style='color:green'>**6行**</span>、<span style='color:blue'>**6列**</span>,的数据，总共有 <span style='color:red'>**7个不同值**</span>

   从第二行开始，就表示这些不同值的具体位置(行列信息 和 值)

   **第二行** ：表示 <span style='color:green'>（第）2（行）</span> <span style='color:blue'>（第）3（列）</span> 有一个 <span style='color:red'>**不同值**</span>，<span style='color:red'>值为 -1</span>，这行其他数据全部是相同值 0

   以此类推.....

   **稀疏数组** 记录了 3*6 = 18个元素，相比于原来的 6\*6=36个元素 起到了一定了压缩作用。



---



​		

#### [队列](https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481?fr=aladdin)

- 队列是一个特殊的线性表，可使用 **数组** 或者 **链表** ...来实现
- 遵循 **先入先出** 原则， 只允许在表的**前端(front)进行删除操作**，在表的**后端(rear)进行插入操作**。

##### **顺序队列**

顺序队列中，每次**插入**一个元素时，**rear +1**，每次**删除**一个元素时，**front + 1**。随着插入和删除操作的进行，队列中元素个数不断变化，队列所占的存储空间也在为队列结构所分配的连续空间中移动。

当 **rear = front** 时，前端，后端指针**指向同一个位置**，说明队列中没有元素，此时为**空队列**。

当 **rear** 增加到分配的空间之外时（**rear** = **maxSize**-1），此时无法插入新元素。满队列

![img](https://bkimg.cdn.bcebos.com/pic/cdbf6c81800a19d8116a4d8030fa828ba71e46ce?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5)

<span style="color:red">**顺序队列中存在的一些问题**</span> ：

1. **下溢** ：队列为空时，出队运算产生的溢出现象，（**队列为空时，没有元素，无法出队，此时出队，产生异常**）下溢是正常现象，常用作程序控制转移的条件。
2. **真上溢**：当队列满时，进队运算产生的空间溢出现象，（**队列被填满时，没有空间，无法存储进队运算送来的数据**）真上溢是一种异常状态，应设法避免，手动处理
3. **假上溢**：由于 **入队** 和 **出队** 操作中，**头（front）尾（rear）指针只增加，不减少**。导致，即使已经出队的元素所占空间，还是无法被重新利用。（当**rear = front = maxSize**-1 时，无法进行 **出队(front +1)，入队(rear +1)** 操作，被空余出来的空间，无法继续使用，造成浪费）



##### **循环队列**

在实际使用过程中，为了使队列空间能重复使用，使用**循环队列**来处理：

无论 **插入** 或 **删除** ，一旦 **rear** 或者 **front** 指针 执行入队/出队操作时，**超出了所分配的队列空间**，就让该指针指向这篇连续空间的起始位置，**指针的值** 变为**0**，可以使用 **rear%maxSize front%maxSize** **取余运算** 来实现。

在循环队列中，**当队列为空时**，**front = rear**，**当所有队列填满时**，**也有 front = rear**。<span style='color:green'>为了区分 空 还是 满，规定循环队列最多只能有maxSize - 1个队列元素，当循环队列中只剩下一个存储单元时，队列是满的状态。</span>所以**队列判空**：<span style='color:red'>front = rear</span>，**队列判满**：<span style='color:red'>front = (rear+1)%maxSize</span>，**有效数据个数** **（rear + maxSize - front） % maxSize**

![img](https://bkimg.cdn.bcebos.com/pic/7dd98d1001e939015d4345bb78ec54e737d196f6?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5)





***



#### 链表

链表是一种物理[存储单元](https://baike.baidu.com/item/存储单元/8727749)上**非连续、非顺序**的[存储结构](https://baike.baidu.com/item/存储结构/350782)，[数据元素](https://baike.baidu.com/item/数据元素/715313)的**逻辑顺序**是通过链表中的[指针](https://baike.baidu.com/item/指针/2878304)链接次序实现的。

链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：

1. 一个是存储[数据元素](https://baike.baidu.com/item/数据元素)的**数据域(data)**。
2. 另一个是存储下一个结点地址的**[指针](https://baike.baidu.com/item/指针/2878304)域(next)**。 

相比于[线性表](https://baike.baidu.com/item/线性表/3228081)[顺序结构](https://baike.baidu.com/item/顺序结构/9845234)，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。

使用链表结构可以克服[数组](https://baike.baidu.com/item/数组/3794097)链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现**灵活**的内存动态管理。

但是链表失去了[数组](https://baike.baidu.com/item/数组/3794097)随机读取的优点，同时链表由于增加了结点的[指针](https://baike.baidu.com/item/指针/2878304)域，**空间开销比较大**。

链表最明显的好处就是，常规[数组](https://baike.baidu.com/item/数组/3794097)排列关联项目的方式可能不同于这些数据项目在[记忆体](https://baike.baidu.com/item/记忆体/3029693)或[磁盘](https://baike.baidu.com/item/磁盘/2842227)上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的[节点](https://baike.baidu.com/item/节点/865052)，但是不允许[随机存取](https://baike.baidu.com/item/随机存取/4610937)。链表有很多种不同的类型：[单向链表](https://baike.baidu.com/item/单向链表/8671935)，[双向链表](https://baike.baidu.com/item/双向链表/2968731)以及[循环链表](https://baike.baidu.com/item/循环链表/3228465)。



##### 特点

用一组任意的[存储单元](https://baike.baidu.com/item/存储单元)存储[线性表](https://baike.baidu.com/item/线性表)的[数据元素](https://baike.baidu.com/item/数据元素)（这组存储单元可以是连续的，也可以是不连续的）。因此，为了表示每个[数据元素](https://baike.baidu.com/item/数据元素) 与其直接后继数据元素 之间的逻辑关系，对数据元素 来说，除了[存储](https://baike.baidu.com/item/存储)其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。由这两部分信息组成一个"结点"，表示线性表中一个[数据元素](https://baike.baidu.com/item/数据元素)。线性表的链式存储有一个缺点，就是要找一个数，必须要从头开始找起，十分麻烦。 





##### 单向链表

<img src="https://bkimg.cdn.bcebos.com/pic/91ef76c6a7efce1b8d7e8131ae51f3deb58f65f7?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U3Mg==,g_7,xp_5,yp_5" alt="img" title="单向链表图示" style="zoom:150%;" />

单向链表，有一个表头节点 hear  ，**最后一个节点的next 指向 null**.  



##### 循环链表

与**单向链表**一样，不同的是，**循环链表的最后一个节点指向的改链表的第一个节点，或者表头节点**。形成了一个环形的链。

1、在建立一个**循环链表**时，必须使其最后一个结点的[指针](https://baike.baidu.com/item/指针)指向表头结点，而不是象**单链表**那样置为NULL。此种情况还在于在最后一个结点后插入一个新的结点。

2、在判断是否到表尾时，是判断该结点链域（next）的值是否是表头结点，当链域值等于表头[指针](https://baike.baidu.com/item/指针)时，说明已到表尾。而非象**单链表**那样判断链域值是否为NULL。



##### 双向链表

双向链表是单向链表的改进。

问题：当我们需要对**单向链表**中的某个节点的前置节点进行操作时，必须从表头开始遍历查找这个节点。这是**单向链表**的结构限制。单向链表每个节点只有一个存储后继节点链域。

为了解决这个问题，**双向链表**就应运而生。在**双向链表**中，节点除了有**数据域**，还有**两个链域**，一个存储前置节点的地址，为**左链域**，一个存储后继节点的地址，为**右链域**。